# Tasks Document

## Phase 1: Core Infrastructure

- [x] 1. Create TUI entry point and vault unlocking logic
  - File: cmd/tui-tview/main.go
  - Implement main() function with vault service initialization, keychain unlock attempt, password prompt fallback, and TUI launch orchestration
  - Purpose: Provide entry point for TUI mode with secure vault unlocking
  - _Leverage: internal/vault/vault.go (VaultService.Unlock, UnlockWithKeychain), internal/keychain (system keychain integration), github.com/howeyc/gopass (masked password input)_
  - _Requirements: 1.1, 1.2, 1.3, 1.4_
  - _Prompt: Implement the task for spec tui-tview-implementation: Role: Go developer implementing CLI applications with secure credential handling | Task: Create the TUI entry point in cmd/tui-tview/main.go with vault unlocking flow - attempt keychain unlock via VaultService.UnlockWithKeychain(), fall back to password prompt using howeyc/gopass for masked input (max 3 attempts), then call launchTUI() function that will be implemented in next tasks. Include main(), launchTUI(vaultService), and promptForPassword() functions following the structure in cmd/tui-tview-skeleton/main.go.md | Restrictions: Do not modify existing vault service code, handle all error cases gracefully with user-friendly messages, exit with appropriate codes (0 success, 1 failure), do not start TUI rendering yet (that's in next tasks) | Success: main.go compiles without errors, vault unlocking works via keychain and password fallback, error messages are clear, proper exit codes used, follows skeleton documentation_

- [x] 2. Implement tview.Application lifecycle and panic recovery
  - File: cmd/tui-tview/app.go
  - Create application configuration, panic recovery, terminal restoration, and graceful shutdown utilities
  - Purpose: Manage tview.Application lifecycle with error handling
  - _Leverage: github.com/rivo/tview.Application, github.com/gdamore/tcell/v2 (terminal control)_
  - _Requirements: 1.5_
  - _Prompt: Implement the task for spec tui-tview-implementation: Role: Go developer specializing in terminal applications and error handling | Task: Implement app.go with functions: NewApp() to create configured tview.Application with mouse support and panic handler, SetRootSafely() to update root primitive using QueueUpdateDraw(), Quit() to gracefully stop application, RestoreTerminal() for emergency terminal restoration on panic. Follow structure from cmd/tui-tview-skeleton/app.go.md | Restrictions: Do not create multiple application instances, must restore terminal state on panic, use tview's built-in alternate screen (no manual configuration needed), enable mouse support by default | Success: app.go compiles, panic recovery restores terminal, NewApp() returns configured application, Quit() cleanly exits, follows skeleton documentation_

- [x] 3. Create AppState with deadlock-free state management
  - File: cmd/tui-tview/models/state.go
  - Implement central application state with thread-safe vault access, credential caching, component storage, and callback notifications following Lock→Mutate→Unlock→Notify pattern
  - Purpose: Provide single source of truth with deadlock prevention
  - _Leverage: internal/vault.VaultService (all vault operations), sync.RWMutex (concurrency control)_
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6_
  - _Prompt: Implement the task for spec tui-tview-implementation: Role: Go developer expert in concurrent programming and mutex management | Task: Create models/state.go with AppState struct containing: RWMutex, VaultService reference, credentials cache, categories list, selection state, component references (sidebar, table, detailView, statusBar), and callbacks. Implement: NewAppState(vault), GetCredentials/GetCategories/GetSelectedCredential (RLock), LoadCredentials/AddCredential/UpdateCredential/DeleteCredential (CRITICAL: Lock→Mutate→Unlock→Notify pattern - never call callbacks while locked!), SetSelected* methods, Set/Get component methods, Set notification callback methods, private notification helpers (notifyCredentialsChanged, notifySelectionChanged, notifyError called AFTER unlock). Follow cmd/tui-tview-skeleton/models/state.go.md deadlock prevention pattern EXACTLY | Restrictions: NEVER call callbacks while holding lock (this caused deadlocks in previous implementations), NEVER use defer for write locks if callbacks will be called, explicit unlock before all notifications, read operations can use defer RLock/RUnlock, all vault operations go through AppState not directly | Success: state.go compiles, all operations follow Lock→Mutate→Unlock→Notify pattern, no deadlocks in concurrent tests, callbacks invoked after unlock, component storage works, follows skeleton documentation precisely_

## Phase 2: Basic Components

- [x] 4. Create Sidebar component with category tree navigation
  - File: cmd/tui-tview/components/sidebar.go
  - Implement Sidebar wrapping tview.TreeView with category display, tree building, selection handling, and refresh logic
  - Purpose: Provide category tree navigation
  - _Leverage: models.AppState (GetCategories, SetSelectedCategory), github.com/rivo/tview.TreeView, cmd/tui-tview/styles/theme.go (colors - will be implemented in task 13)_
  - _Requirements: 3.1, 3.2, 3.6_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: Go developer implementing TUI components with tview | Task: Create components/sidebar.go with Sidebar struct embedding tview.TreeView, fields for appState and rootNode. Implement: NewSidebar(appState) to create TreeView with root "All Credentials" node and setup, Refresh() to rebuild tree from appState.GetCategories() (clear children, add category nodes, expand root), onSelect() handler calling appState.SetSelectedCategory(), applyStyles() for borders and colors. Tree structure: root node "All Credentials" with category children. Follow cmd/tui-tview-skeleton/components/sidebar.go.md | Restrictions: Only read from AppState (GetCategories), never modify state directly except via SetSelectedCategory, create component once and reuse (stored in AppState), use styles from theme.go when available or hardcode tcell colors temporarily, SetSelectedFunc for selection not keyboard intercept | Success: sidebar.go compiles, tree builds correctly from categories, selection updates AppState, Refresh() rebuilds tree, rounded borders applied, follows skeleton documentation_

- [x] 5. Create Table component for credential list display
  - File: cmd/tui-tview/components/table.go
  - Implement CredentialTable wrapping tview.Table with filtering, column layout, selection handling, and refresh logic
  - Purpose: Display filtered credential list in table format
  - _Leverage: models.AppState (GetCredentials, GetSelectedCategory, SetSelectedCredential), internal/vault.Credential (type), github.com/rivo/tview.Table, cmd/tui-tview/styles/theme.go_
  - _Requirements: 3.1, 3.2, 3.6_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: Go developer implementing TUI table components | Task: Create components/table.go with CredentialTable struct embedding tview.Table, fields for appState, filteredCreds, selectedIndex. Implement: NewCredentialTable(appState) to create Table with fixed header and setup, Refresh() to get credentials, filter by selected category, clear table, populate rows (service, username, last used columns), restore selection, buildHeader() to create fixed header row with column titles, populateRows() to add credential rows with cell metadata, onSelect() handler calling appState.SetSelectedCredential(), filterByCategory() helper, applyStyles() for borders and colors. Follow cmd/tui-tview-skeleton/components/table.go.md | Restrictions: Only read from AppState, filter credentials by selected category (empty = show all), store credential reference in cell metadata for selection, use SetSelectedFunc not keyboard intercept, header row should be fixed (row 0), use styles temporarily or hardcode | Success: table.go compiles, displays credentials in columns, filters by category correctly, selection updates AppState, Refresh() rebuilds table, follows skeleton documentation_

- [x] 6. Create DetailView component for credential details
  - File: cmd/tui-tview/components/detail.go
  - Implement DetailView wrapping tview.TextView with credential formatting, password visibility toggle, and clipboard copy
  - Purpose: Display selected credential details with actions
  - _Leverage: models.AppState (GetSelectedCredential), github.com/rivo/tview.TextView, github.com/atotto/clipboard (copy password), cmd/tui-tview/styles/theme.go_
  - _Requirements: 3.1, 3.2, 3.6, 7.4_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: Go developer implementing TUI detail views | Task: Create components/detail.go with DetailView struct embedding tview.TextView, fields for appState and passwordVisible bool. Implement: NewDetailView(appState) to create TextView with dynamic text and setup, Refresh() to get selected credential and format display using formatCredential(), TogglePasswordVisibility() to toggle passwordVisible flag and refresh, CopyPasswordToClipboard() using clipboard.WriteAll() returning error, formatCredential() to create formatted text showing service, username, password (masked if !passwordVisible as "********"), URL, notes, timestamps. Follow cmd/tui-tview-skeleton/components/detail.go.md | Restrictions: Only read from AppState (GetSelectedCredential), do not modify credentials, handle nil credential gracefully (show "No credential selected"), use existing clipboard library, passwordVisible state is internal to component, use styles or hardcode temporarily | Success: detail.go compiles, formats credential display correctly, password toggle works, clipboard copy works, handles nil selection, Refresh() updates display, follows skeleton documentation_

- [x] 7. Create StatusBar component with context-aware shortcuts
  - File: cmd/tui-tview/components/statusbar.go
  - Implement StatusBar wrapping tview.TextView with context-aware keyboard shortcut display and status messages
  - Purpose: Show available shortcuts and status messages
  - _Leverage: models.AppState, github.com/rivo/tview.TextView, cmd/tui-tview/styles/theme.go_
  - _Requirements: 3.1, 3.4, 7.4_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: Go developer implementing TUI status bars | Task: Create components/statusbar.go with StatusBar struct embedding tview.TextView, field for appState. Define FocusContext enum (FocusSidebar, FocusTable, FocusDetail, FocusModal). Implement: NewStatusBar(appState) to create TextView with initial text and setup, UpdateForContext(focus FocusContext) to display shortcuts for current context, ShowSuccess(message) to temporarily show success message, ShowError(err error) to show error message, getShortcutsForContext() helper returning shortcut text per context. Examples: Table→"[n] New  [e] Edit  [d] Delete  [c] Copy  [?] Help  [q] Quit", Detail→"[e] Edit  [d] Delete  [p] Toggle  [c] Copy  [?] Help  [q] Quit". Follow cmd/tui-tview-skeleton/components/statusbar.go.md | Restrictions: Text only, no borders, fixed height (1 row), use dark background color for status bar, message display should be temporary (components will call UpdateForContext to restore shortcuts), format with color tags like "[cyan]Text[-]" | Success: statusbar.go compiles, shows correct shortcuts per context, success/error messages display, context updates work, follows skeleton documentation_

## Phase 3: Forms

- [ ] 8. Create Add and Edit credential forms
  - File: cmd/tui-tview/components/forms.go
  - Implement AddForm and EditForm wrapping tview.Form with input fields, validation, and submit/cancel callbacks
  - Purpose: Provide modal forms for credential CRUD operations
  - _Leverage: models.AppState (AddCredential, UpdateCredential), github.com/rivo/tview.Form, cmd/tui-tview/styles/theme.go_
  - _Requirements: 3.5, 7.1, 7.2_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: Go developer implementing TUI forms and validation | Task: Create components/forms.go with two structs: AddForm and EditForm, both embedding tview.Form with appState field and onSubmit/onCancel callback fields. Implement: NewAddForm(appState) to create Form with input fields (Service, Username, Password, Category, URL, Notes), AddButton("Add") calling validation then appState.AddCredential() then onSubmit callback, AddButton("Cancel") calling onCancel, apply form styles. NewEditForm(appState, credential) similar but pre-populated with credential values, "Save" button calls appState.UpdateCredential(). Both have SetOnSubmit(func()) and SetOnCancel(func()) methods to register callbacks. Follow cmd/tui-tview-skeleton/components/forms.go.md | Restrictions: Validate inputs before calling AppState methods (service and username required minimum), do not allow empty service name, call callbacks after successful operation, forms should not close themselves (EventHandler manages modal close), use Form.AddInputField() for text, AddPasswordField() for password (masked input), apply theme colors | Success: forms.go compiles, both forms create correctly, input fields work, validation prevents invalid submissions, callbacks invoked after successful add/update, follows skeleton documentation_

## Phase 4: Layout Management

- [ ] 9. Implement responsive LayoutManager with breakpoints
  - File: cmd/tui-tview/layout/manager.go
  - Create LayoutManager with responsive layout building, breakpoint detection, and dynamic panel visibility
  - Purpose: Manage responsive layout adapting to terminal size
  - _Leverage: models.AppState (component references), github.com/rivo/tview.Flex, github.com/gdamore/tcell/v2 (screen size)_
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: Go developer implementing responsive layouts | Task: Create layout/manager.go with LayoutMode enum (LayoutSmall <80, LayoutMedium 80-120, LayoutLarge >120), LayoutManager struct with app, appState, width/height, currentMode, mainLayout/contentRow Flex, component references, breakpoints (medium=80, large=120). Implement: NewLayoutManager(app, appState) constructor, CreateMainLayout() to build vertical Flex with contentRow (flex) and statusBar (fixed 1 row), setup resize detection with SetDrawFunc, HandleResize(width, height) to check mode change and call rebuildLayout if needed, rebuildLayout() to clear contentRow and add components based on mode (Small: table only, Medium: sidebar(20)+table(flex), Large: sidebar(20)+table(flex)+detail(40)), determineLayoutMode(width) returning LayoutMode, GetCurrentMode(), SetBreakpoints(medium, large). Follow cmd/tui-tview-skeleton/layout/manager.go.md | Restrictions: Components must be retrieved from AppState not created new, use Flex.AddItem(primitive, size, proportion, focus), breakpoints fixed at 80 and 120 unless changed via SetBreakpoints, resize detection via SetDrawFunc checking screen.Size(), layout rebuild should reuse existing components | Success: manager.go compiles, layout builds correctly for all modes, breakpoints work at 79/80/119/120 columns, resize triggers rebuild, component visibility correct per mode, follows skeleton documentation_

- [ ] 10. Implement PageManager for modal and page management
  - File: cmd/tui-tview/layout/pages.go
  - Create PageManager wrapping tview.Pages with modal stack management and helper methods for showing forms/dialogs
  - Purpose: Manage modal dialogs and page switching
  - _Leverage: github.com/rivo/tview.Pages, github.com/rivo/tview.Modal, github.com/rivo/tview.Form, cmd/tui-tview/styles/theme.go_
  - _Requirements: 3.5, 6.4, 7.1, 7.2, 7.3_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: Go developer implementing modal management systems | Task: Create layout/pages.go with PageManager struct embedding tview.Pages, fields for app and modalStack []string. Implement: NewPageManager(app) constructor, ShowModal(name, modal tview.Primitive, width, height) to add modal to Pages and push to stack, ShowForm(form *tview.Form, title string) helper wrapping form in centered modal, ShowConfirmDialog(title, message, onYes, onNo func()) to create and show confirmation modal with Yes/No buttons, CloseModal(name) to hide page and remove from stack, CloseTopModal() to close last modal in stack, HasModals() returning bool, ShowPage(name, primitive) for non-modal pages, SwitchToPage(name) to change active page. Follow cmd/tui-tview-skeleton/layout/pages.go.md | Restrictions: Modal stack tracks order for proper close operations, modals should be centered using Modal or custom Flex centering, form modals use ShowForm helper not ShowModal directly, confirmation dialog must call appropriate callback and close modal, Pages primitive is root of application when modals shown over main layout | Success: pages.go compiles, modals show/hide correctly, stack management works, form helper centers forms with title, confirm dialog calls callbacks, follows skeleton documentation_

## Phase 5: Event Handling

- [ ] 11. Implement global EventHandler with input protection
  - File: cmd/tui-tview/events/handlers.go
  - Create EventHandler with global keyboard shortcuts and CRITICAL input protection for forms
  - Purpose: Route keyboard shortcuts with form input protection
  - _Leverage: models.AppState (all state operations), layout.PageManager (modal management), components (all), github.com/gdamore/tcell/v2 (keyboard events)_
  - _Requirements: 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: Go developer expert in event handling and keyboard shortcuts | Task: Create events/handlers.go with EventHandler struct containing app, appState, nav (navigation state), pageManager, statusBar references. Implement: NewEventHandler(...) constructor, SetupGlobalShortcuts() installing app.SetInputCapture with CRITICAL input protection pattern (check focused component type, if Form/InputField/TextArea then return event except Ctrl+C, otherwise handle shortcuts), handleGlobalKey(event) routing keys: q=quit, n=new credential, e=edit, d=delete, p=toggle password, c=copy, ?=help, Tab=cycle focus, Shift+Tab=reverse focus, Ctrl+C=force quit. Action handlers: handleQuit() checking modals first, handleNewCredential() creating AddForm and showing via pageManager, handleEditCredential() getting selected credential and showing EditForm, handleDeleteCredential() showing confirm dialog, handleTogglePassword() calling detailView method, handleCopyPassword() calling detailView method, handleShowHelp() showing modal with help text, handleTabFocus() calling nav.CycleFocus(), handleShiftTabFocus() calling nav.CycleFocusReverse(). Follow cmd/tui-tview-skeleton/events/handlers.go.md INPUT PROTECTION PATTERN EXACTLY | Restrictions: CRITICAL - must check focused component type before intercepting keys (switch focused.(type) case *tview.Form, *tview.InputField, *tview.TextArea: return event), NEVER intercept keys for input components except Ctrl+C, all shortcuts pass through to input fields when focused, action handlers use pageManager for modals not direct display, callbacks should update status bar, form submit callbacks must close modal via pageManager | Success: handlers.go compiles, input protection works (can type 'e' 'n' 'd' in forms), shortcuts work outside forms, all actions execute correctly, modals managed properly, follows skeleton input protection pattern precisely_

- [ ] 12. Implement focus cycling and management
  - File: cmd/tui-tview/events/focus.go
  - Create NavigationState for managing focus between components with Tab cycling
  - Purpose: Enable Tab-based focus cycling between panels
  - _Leverage: models.AppState (component references), tview.Application (SetFocus), cmd/tui-tview/styles/theme.go (border colors)_
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: Go developer implementing focus management | Task: Create events/focus.go with FocusTarget enum (FocusSidebar, FocusTable, FocusDetail), NavigationState struct containing app, appState, focusOrder []tview.Primitive, currentIndex int. Implement: NewNavigationState(app, appState) building focusOrder from appState components, CycleFocus() advancing currentIndex and calling setFocus, CycleFocusReverse() decrementing currentIndex and calling setFocus, SetFocus(target FocusTarget) directly setting focus, GetCurrentFocus() returning FocusTarget, SetFocusOrder(order) updating focusOrder, private setFocus(index) calling app.SetFocus() and updating border colors (active component gets active border color, others get inactive - use styles.ApplyBorderedStyle if available). Follow cmd/tui-tview-skeleton/events/focus.go.md | Restrictions: Focus order must match visible components only (skip hidden components in small/medium layouts), wrap index on cycle (0→len-1, len→0), update visual feedback (border colors) when focus changes, only cycle between main panels not modals, modals auto-focus when shown | Success: focus.go compiles, Tab cycles focus correctly, border colors update on focus change, hidden components skipped, reverse cycle works, follows skeleton documentation_

## Phase 6: Supporting Files

- [ ] 13. Create theme and styling system
  - File: cmd/tui-tview/styles/theme.go
  - Implement ColorScheme struct with Dracula-inspired palette and styling helper functions
  - Purpose: Centralize color definitions and component styling
  - _Leverage: github.com/gdamore/tcell/v2.NewRGBColor, github.com/rivo/tview primitives_
  - _Requirements: 8.1, 8.2, 8.3, 8.4, 8.5_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: Go developer implementing theming systems | Task: Create styles/theme.go with ColorScheme struct containing all theme colors (Background, BackgroundLight, BackgroundDark, BorderColor, BorderInactive, TextPrimary, TextSecondary, TextAccent, Success, Error, Warning, Info, TableHeader, TableSelected, SidebarSelected, StatusBarBg, ButtonBackground, ButtonText). Create DefaultTheme variable with Dracula-inspired colors using tcell.NewRGBColor (Background:#282a36, BorderColor:#8be9fd cyan, TextPrimary:#f8f8f2 white, Success:#50fa7b green, Error:#ff5555 red, etc - see skeleton for full palette). Implement: GetCurrentTheme() returning DefaultTheme, SetRoundedBorders() setting tview.Borders characters (╭╮╰╯─│), ApplyBorderedStyle(primitive, title, active) applying borders and colors based on active state, ApplyTableStyle(table) setting table colors and selected style, ApplyFormStyle(form) setting form field colors, color helpers Lighten(color, amount) and Darken(color, amount). Follow cmd/tui-tview-skeleton/styles/theme.go.md with exact color values | Restrictions: Use exact RGB values from skeleton (Dracula theme), rounded borders should use Unicode box drawing chars, ApplyBorderedStyle must work with all tview primitive types (use type switch), active vs inactive border colors critical for focus feedback, color helpers should manipulate RGB components | Success: theme.go compiles, DefaultTheme has all colors defined correctly, rounded borders display properly, border styling works for all primitive types, focus colors distinguish active/inactive components, follows skeleton color palette exactly_

- [ ] 14. Update all components to use theme.go styling
  - Files: cmd/tui-tview/components/sidebar.go, components/table.go, components/detail.go, components/statusbar.go, components/forms.go
  - Replace hardcoded colors in all components with theme.go references
  - Purpose: Ensure consistent styling across all components
  - _Leverage: cmd/tui-tview/styles/theme.go (now implemented)_
  - _Requirements: 8.1, 8.3_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: Go developer refactoring for consistency | Task: Update all component files to use styles.GetCurrentTheme() and styles helper functions instead of hardcoded tcell.NewRGBColor calls. In sidebar.go: use styles.ApplyBorderedStyle() and theme colors. In table.go: use styles.ApplyTableStyle() and theme colors. In detail.go: use styles.ApplyBorderedStyle() and theme colors. In statusbar.go: use theme.StatusBarBg and theme text colors. In forms.go: use styles.ApplyFormStyle() and theme colors. Import "pass-cli/cmd/tui-tview/styles" in all files. Call styles.SetRoundedBorders() in main.go after app creation | Restrictions: Do not change component logic, only color/styling calls, ensure all components use consistent theme colors, remove any hardcoded RGB values, maintain existing styling behavior | Success: All components use theme.go, no hardcoded colors remain, styling is consistent across components, rounded borders display everywhere, components compile without errors_

## Phase 7: Integration

- [ ] 15. Wire everything together and register tui command
  - Files: cmd/tui-tview/main.go (complete launchTUI), cmd/root.go (register command)
  - Complete launchTUI() function to instantiate and wire all components, then register new `tui` command in root.go
  - Purpose: Integrate all components and enable TUI launch via `pass-cli tui`
  - _Leverage: All implemented components, models, layout, events from previous tasks, cmd/root.go existing command patterns_
  - _Requirements: All requirements (complete integration)_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: Go developer completing system integration | Task: Part 1 - Complete launchTUI() in cmd/tui-tview/main.go: Create app using NewApp(), defer RestoreTerminal(), create AppState with vault, load credentials via appState.LoadCredentials(), create all components (NewSidebar, NewCredentialTable, NewDetailView, NewStatusBar, NewAddForm, NewEditForm), store components in AppState via Set methods, register callbacks (onCredentialsChanged→refresh all components, onSelectionChanged→refresh detail, onError→show in status bar), create NavigationState, create LayoutManager and build layout via CreateMainLayout(), create PageManager, create EventHandler and call SetupGlobalShortcuts(), set root via app.SetRoot(layout, true), call app.Run() returning error. Part 2 - Register command in cmd/root.go: Import "pass-cli/cmd/tui-tview", add tuiCmd using cobra.Command with Use:"tui", Short:"Launch interactive TUI dashboard", Run: calling tui-tview.LaunchTUI() (must export LaunchTUI as public function), add tuiCmd to rootCmd with rootCmd.AddCommand(tuiCmd). Follow integration pattern from cmd/tui-tview-skeleton/main.go.md | Restrictions: Create components in correct order (models first, then components, then layout, then events), register all callbacks before calling Run(), export LaunchTUI function to be called from root.go, follow existing command registration patterns in root.go, ensure proper error handling throughout integration, application should block in Run() until user quits | Success: launchTUI() creates and wires all components correctly, callbacks registered properly, `pass-cli tui` command launches TUI successfully, all components visible and functional, no panics on startup, graceful shutdown on quit, integration complete_

## Testing and Validation

- [ ] 16. Create unit tests for core components
  - Files: cmd/tui-tview/models/state_test.go, cmd/tui-tview/components/sidebar_test.go, cmd/tui-tview/components/table_test.go, cmd/tui-tview/layout/manager_test.go
  - Write unit tests for state management, component refresh logic, and layout mode determination
  - Purpose: Ensure core logic reliability and catch regressions
  - _Leverage: testing package, mock vault service for state tests_
  - _Requirements: All non-functional requirements_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: QA engineer writing Go unit tests | Task: Create unit tests for: models/state_test.go - test LoadCredentials with mock vault, test Add/Update/Delete credential operations, test callback invocation after unlock (critical deadlock prevention verification), test concurrent access with goroutines, test component storage/retrieval. components/sidebar_test.go - test Refresh rebuilds tree, test selection updates AppState, test category filtering. components/table_test.go - test Refresh with filtering, test selection handling, test row population. layout/manager_test.go - test determineLayoutMode for all breakpoints (79→Small, 80→Medium, 119→Medium, 120→Large), test rebuildLayout for each mode, verify component visibility. Use table-driven tests where appropriate, mock VaultService for state tests, use go test -race to verify no data races | Restrictions: Tests must be isolated (no dependencies between tests), mock external dependencies (vault service, terminal), focus on logic not UI rendering (tview rendering not testable), verify deadlock prevention pattern (Lock→Unlock→Notify), test both success and error scenarios | Success: All test files compile, tests pass with go test ./cmd/tui-tview/..., no race conditions detected with -race flag, critical deadlock prevention verified, good coverage of core logic_

- [ ] 17. Manual testing and cross-platform validation
  - Test the complete TUI on all supported platforms
  - Purpose: Validate user experience and terminal compatibility
  - _Leverage: Completed TUI implementation, test vault with sample credentials_
  - _Requirements: All functional requirements_
  - _Prompt: Read the requirements and design for the spec tui-tview-implementation and implement this task: Role: QA engineer performing manual testing | Task: Execute manual testing checklist: 1) Launch with keychain unlock, 2) Launch with password prompt, 3) Navigate categories with arrow keys, 4) Select credential view details, 5) Add new credential via 'n', 6) Edit credential via 'e', 7) Delete credential via 'd' with confirmation, 8) Copy password via 'c', 9) Toggle password visibility via 'p', 10) Resize terminal test all breakpoints (<80, 80-120, >120 columns), 11) Press '?' for help screen, 12) Test all keyboard shortcuts, 13) Quit with 'q' and Ctrl+C, 14) Test form input (verify can type 'e' 'n' 'd' in forms without triggering shortcuts). Cross-platform: Test on Windows (Windows Terminal, PowerShell), macOS (iTerm2, Terminal.app), Linux (gnome-terminal, Alacritty). Terminal compatibility: Test colors (256-color, true color), test borders (rounded display correctly), test mouse support (enabled/disabled), test alternate screen (terminal restores on quit) | Restrictions: Test on actual terminals not emulators when possible, verify rounded borders display correctly (may fallback on some terminals), test with real vault file not mock data, verify all keyboard shortcuts work as documented, ensure form input protection works (critical bug fix from previous implementations) | Success: TUI works on all platforms (Windows, macOS, Linux), all features functional, keyboard shortcuts work correctly, form input not intercepted, layout adapts to terminal size, colors display correctly, borders render properly, terminal restores on exit, no crashes or hangs, user experience is smooth and intuitive_
